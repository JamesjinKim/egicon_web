
⏺ EG-ICON Dashboard 프로토타입 구현 계획 (1주 완성)
  ================================================================================
  프로토타입 범위: 목업 데이터 기반 웹 대시보드 + 기본 API
  ================================================================================

  Day 1 (월요일): 백엔드 기본 구조 - 6시간
  ================================================================================
  시간    | 작업명                    | 파일명              | 상세 내용                    | 소요시간
  -------|-------------------------|-------------------|----------------------------|----------
  09:00   | 프로젝트 초기 설정         | 폴더 구조 생성      | 기본 폴더, requirements.txt   | 1시간
  10:00   | FastAPI 기본 설정          | main.py            | 앱 생성, CORS 설정            | 1시간
  11:00   | 목업 데이터 생성           | api/mock_data.py   | 16개 센서 가상 데이터         | 2시간
  14:00   | 기본 API 라우트            | api/routes.py      | 센서 데이터 조회 API          | 2시간

  Day 2 (화요일): 실시간 통신 및 데이터 처리 - 6시간
  ================================================================================
  시간    | 작업명                    | 파일명              | 상세 내용                    | 소요시간
  --------|-------------------------|---------------------|-------------------------|----------
  09:00   | WebSocket 기본 구현        | api/websocket.py   | 실시간 데이터 스트리밍        | 2시간
  11:00   | 목업 데이터 변화 로직        | api/mock_data.py   | 시간에 따른 센서 값 변화      | 2시간
  14:00   | API 테스트                | tests/test_api.py  | 기본 API 동작 확인            | 1시간
  15:00   | 정적 파일 서빙             | main.py            | 프론트엔드 파일 서빙 설정     | 1시간

  Day 3 (수요일): 프론트엔드 기본 구조 - 6시간
  ================================================================================
  시간    | 작업명                    | 파일명              | 상세 내용                    | 소요시간
  --------|------------------------|---------------------|---------------------------|----------
  09:00   | HTML 기본 구조             | frontend/index.html | 대시보드 레이아웃            | 2시간
  11:00   | CSS 스타일링              | frontend/style.css | 기본 스타일, 반응형 그리드    | 2시간
  14:00   | Chart.js 라이브러리       | frontend/lib/      | 차트 라이브러리 설정          | 1시간
  15:00   | JavaScript 기본 구조      | frontend/app.js    | 모듈 구조, 이벤트 핸들링      | 1시간

  Day 4 (목요일): 프론트엔드 기능 구현 - 6시간
  ================================================================================
  시간    | 작업명                    | 파일명              | 상세 내용                    | 소요시간
  --------|---------------------------|---------------------|------------------------------|----------
  09:00   | API 클라이언트 구현        | frontend/app.js    | REST API 호출 함수            | 2시간
  11:00   | 실시간 차트 구현          | frontend/app.js    | Chart.js 실시간 업데이트      | 2시간
  14:00   | WebSocket 클라이언트      | frontend/app.js    | 실시간 데이터 수신            | 2시간

  Day 5 (금요일): 완성 및 테스트 - 6시간
  ================================================================================
  시간    | 작업명                    | 파일명              | 상세 내용                    | 소요시간
  --------|---------------------------|---------------------|------------------------------|----------
  09:00   | 센서 상태 표시 UI          | frontend/          | 온라인/오프라인 상태 표시     | 2시간
  11:00   | 데이터 히스토리 기능       | frontend/app.js    | 과거 데이터 차트 표시         | 2시간
  14:00   | 통합 테스트               | 전체               | 전체 시스템 동작 확인         | 1시간
  15:00   | 문서화 및 배포 준비        | README.md          | 실행 방법, 데모 설명          | 1시간

  ================================================================================
  최소 파일 구조
  ================================================================================
  sensor_dashboard/
  ├── main.py                 # FastAPI 앱 진입점
  ├── requirements.txt        # 의존성 (fastapi, uvicorn, websockets)
  ├── api/
  │   ├── __init__.py
  │   ├── routes.py          # REST API 라우트
  │   ├── websocket.py       # WebSocket 핸들러
  │   └── mock_data.py       # 목업 데이터 생성기
  ├── frontend/
  │   ├── index.html         # 메인 대시보드
  │   ├── style.css          # 스타일시트
  │   ├── app.js             # 메인 JavaScript
  │   └── lib/
  │       └── chart.min.js   # Chart.js 라이브러리
  └── tests/
      └── test_api.py        # 기본 API 테스트

  ================================================================================
  프로토타입 기능 범위
  ================================================================================
  ✅ 포함 기능:
  - 16개 센서 목업 데이터 (BME680, BH1750, 진동, 차압)
  - 실시간 차트 업데이트 (Chart.js)
  - WebSocket 실시간 통신
  - 센서 상태 표시 (온라인/오프라인)
  - 반응형 웹 디자인
  - 기본 API 엔드포인트 (GET /api/sensors)
  - 실제 하드웨어 연동
  - 데이터베이스 저장

  ================================================================================
  목업 데이터 시나리오
  ================================================================================
  센서 타입      | 데이터 포인트              | 변화 패턴
  ---------------|----------------------------|---------------------------
  BME680         | 온도(20-30°C), 습도(40-80%), 압력(1000-1020hPa) | 사인파 + 랜덤 노이즈
  BH1750         | 조도(100-2000lux)         | 시간대별 변화 + 랜덤
  진동 센서      | 진동(0-10)               | 임펄스 + 랜덤 스파이크
  차압 센서      | 차압(-5 to +5 Pa)        | 선형 증감 + 랜덤

  ================================================================================
  성능 목표 (프로토타입)
  ================================================================================
  - 메모리 사용량: 30MB 이하
  - API 응답시간: 50ms 이하
  - WebSocket 업데이트: 1초 주기
  - 동시 연결: 3-5개 클라이언트
  - 브라우저 지원: 모던 브라우저 (Chrome, Firefox)


  1. egicon_dash의 CSS 스타일을 그대로 사용할지, 아니면 커스터마이징할지?
  2. 센서 위젯의 16개 배치 방식: 4x4 그리드 vs 동적 그리드?
  3. Mock 데이터의 현실성: 실제 센서와 유사한 데이터 패턴 생성 방법?
  4. 성능 최적화 우선순위: 메모리 vs 응답속도 vs 실시간성?

  1. egicon_dash의 CSS 스타일을 그대로 사용할지 여부 => 대부분 수용하되 차트를 좀더 모던하고 세련된 스타일로 다듬어 줘.
  2. 센서 위젯의 16개 배치 방식은 동적으로 현재까지 연결된 센서의 위젯을 보여 주면 됩니다.
  3. Mock 데이터는 연결이 없을 경우 기본적인 차트가 보이게 해주는 차트 용 Mock 데이터 이면 됩니다.
  4. 성능 최적화 우선순위: 1.메모리 2.실시간성 3.응답속도 순서로 해주세요.

  Raspberry Pi (I2C Master)
    |  │
    |  └──Challel 0 - TCA9548A Multiplexer (I2C Address: 0x70)
    |                  ├── Channel 0 → SHT40 센서 (0x44)
    |                  ├── Channel 1 → BME688 센서 (0x76)
    |                  ├── Channel 2 → BH1750 센서 (0x23)
    |                  ├── Channel 3 → 추가 센서...
    |                  ├── ...
    |                  └── Channel 7 → 16번째 센서
    └──Challel 1 - TCA9548A Multiplexer (I2C Address: 0x70)
                      ├── Channel 0 → SHT40 센서 (0x44)
                      ├── Channel 1 → BME688 센서 (0x76)
                      ├── Channel 2 → BH1750 센서 (0x23)
                      ├── Channel 3 → 추가 센서...
                      ├── ...
                      └── Channel 7 → 16번째 센서

TCA9548A 실제 스캔 기능 구현 계획                                                                                                                                                                             │ │
│ │                                                                                                                                                                                                               │ │
│ │ Phase 1: I2C 스캔 기반 구조 구축                                                                                                                                                                              │ │
│ │                                                                                                                                                                                                               │ │
│ │ 1. I2C 통신 모듈 개발 (hardware/i2c_scanner.py)                                                                                                                                                               │ │
│ │   - smbus2 라이브러리를 활용한 I2C 통신                                                                                                                                                                       │ │
│ │   - sudo i2cdetect -y 0/1 기능을 Python으로 구현                                                                                                                                                              │ │
│ │   - 버스별 주소 스캔 및 응답 확인                                                                                                                                                                             │ │
│ │ 2. TCA9548A 제어 클래스 (hardware/tca9548a.py)                                                                                                                                                                │ │
│ │   - 멀티플렉서 채널 전환 (0-7)                                                                                                                                                                                │ │
│ │   - 채널별 센서 스캔                                                                                                                                                                                          │ │
│ │   - 기본 주소 0x70 지원                                                                                                                                                                                       │ │
│ │ 3. 센서 검색 로직 (hardware/sensor_detector.py)                                                                                                                                                               │ │
│ │   - 주소 기반 센서 타입 자동 인식                                                                                                                                                                             │ │
│ │   - SHT40(0x44), BME688(0x76), BH1750(0x23) 등 매핑                                                                                                                                                           │ │
│ │   - 센서 응답 검증                                                                                                                                                                                            │ │
│ │                                                                                                                                                                                                               │ │
│ │ Phase 2: API 엔드포인트 실제 구현                                                                                                                                                                             │ │
│ │                                                                                                                                                                                                               │ │
│ │ 1. /api/sensors/scan-dual-mux                                                                                                                                                                                 │ │
│ │   - Bus 0, Bus 1 순차 스캔                                                                                                                                                                                    │ │
│ │   - TCA9548A 멀티플렉서 감지                                                                                                                                                                                  │ │
│ │   - 16채널 전체 스캔 결과 반환                                                                                                                                                                                │ │
│ │ 2. /api/sensors/scan-bus/{bus}                                                                                                                                                                                │ │
│ │   - 단일 버스 스캔                                                                                                                                                                                            │ │
│ │   - 해당 버스의 8채널 검색                                                                                                                                                                                    │ │
│ │ 3. 센서 테스트 API                                                                                                                                                                                            │ │
│ │   - 개별 센서 통신 검증                                                                                                                                                                                       │ │
│ │   - 실제 데이터 읽기 테스트                                                                                                                                                                                   │ │
│ │                                                                                                                                                                                                               │ │
│ │ Phase 3: UI 연동 및 호환성                                                                                                                                                                                    │ │
│ │                                                                                                                                                                                                               │ │
│ │ 1. Mock/Real 모드 전환                                                                                                                                                                                        │ │
│ │   - 환경변수 또는 설정으로 모드 선택                                                                                                                                                                          │ │
│ │   - 개발환경(Mac)에서는 Mock, 라즈베리파이에서는 Real                                                                                                                                                         │ │
│ │ 2. 실시간 상태 업데이트                                                                                                                                                                                       │ │
│ │   - 스캔 결과를 settings 페이지에 실시간 반영                                                                                                                                                                 │ │
│ │   - 에러 상황 처리 및 사용자 알림